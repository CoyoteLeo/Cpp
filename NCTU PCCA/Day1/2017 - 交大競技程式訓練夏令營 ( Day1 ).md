---
robots: index, follow
tags: NCTU, PCCA
lang: zh-tw
dir: ltr
breaks: true
disqus: hackmd
---
# 2017 - 交大競技程式訓練夏令營 ( Day1 )

## A

題目敘述：
現在有一堆花要排序，花有兩種顏色（R, W)
題目給一個k值，代表W花朵一次就要出現k個
以及總長度
問總共有幾種排序方式

題解：
DP轉移式：$\forall x:dp(x)=dp(x-1)+dp(x-k)$ (mod 1e9+7)
dp(x)代表length x的排列法(因為可以用一個linear grammar去產生所有排列情形)，對dp(x)取前綴和，供下面所有query查詢
:$query(a,b) = dp(b)-dp(a-1)$

## B

題目敘述：
有編號 1~n 的加速器, 題目要求啟動中的加速器兩兩編號要互質, 給加入和刪除的操作, 問每個操作是否合法

題解：
先用篩法把 1~n 數字的質因數都求出來
```
vector<int> fac[MAXN];
for (int i=2; i<MAXN; i++){
    if (fac[i].size()!=0)continue;
    
    for (int j=i; j<MAXN; j+=i){
        fac[j].push_back(i);
    }
}
```
因為啟用的數字兩兩互質, 每個質數只會分派給其中一個加速器
用一個 host[p] 記錄目前質數 p 分配給哪個加速器
加入 d 時檢查 d 的所有質因數是否都還沒被分派給其他加速器
刪除 d 時將 d 的所有質因數取消分派



## C

題目敘述:
almost prime 就是只由兩個質數以及它們的乘積所構成的數。
求1~input之間有幾個almost prime

題解:
因為題目數字不太大所以就建個質數表硬尻就好了XD
也可以C(n,2)把每種可能也建個表

## D

題目敘述:
往前走就是+
往後走就是-
WiFi訊號不好所以有可能會收到不一樣的訊息或是未知的訊息
未知用?表示 Dreamoon會用丟硬幣的方式決定"?"時要往前還是往後
求最後走到目的地的機率為何

題解:
把上面那排的+號下面的+號直接無視順序抵銷
-號也是抵銷
如果下排只剩下問號的話那
$Ans = \frac{C_+^?}{2^?}$
如果不只有問號的話表示無解

## E

題目敘述:
給你 NxN 的矩陣
問你所有從左上角到右下角的路徑中
乘積的尾巴0最少的 ( 8700 有 2 個尾巴 0 )

題解:
因為要有尾巴 0 一定是由 2 和 5 組成的
單找所有 path 乘積有最少的 2 ( dp 一下很簡單的 )
單找所有 path 乘積有最少的 5 ( dp 一下很簡單的 )
再找裡面最小的就是答案了
因為如果有另一條 path 比他們更小，就會矛盾
最後，還要注意可能有　path 包含 0 所以乘積是 0 ( 可能也是答案 )

## F

題目敘述:
美麗的序列是序列裡所有數值取gcd的直>1
現在給你一個序列 你可以對此序列做一種操作
將a[i]和a[i+1] 兩元素刪除
把a[i]-a[i+1] 和 a[i]+a[i+1] 放回刪除的地方
問你是否可以使序列變成美麗的序列，如果可以請輸出最少需要做幾次操做
 
題解:
先看看原來序列是否為美麗的序列，如果是就是答案了
如果不是 那麼就只有可能是2（因為你再加減的過程中只有可能是原來的因數或是2 你可以證明一下）
現在來看一下 那個操作的性質

奇 奇 → 偶 偶
奇 偶 → 奇 奇
偶 奇 → 奇 奇
偶 偶 → 偶 偶

所以greedy一下 從前面開始讓他們全部變成偶數
如果是 奇 奇 就操作一次
如果是 奇 偶 或 偶 奇 就操作兩次
如果是 偶 偶 就不要動

對了 唯一的不可能解是只有一個數字，且這個數字剛好為1，其他你都可用上面的方法做出全部都偶數的。


## G

題目敘述:
你有 K 個顏色的球，第 i 顆有 C[i] 個，放在袋子裡，一個一個抽出來。
你知道，第 i 種球的最後一顆在第 i + 1 種球的最後一顆取出來之前就被取出來了。
問組合數 % (1e9 + 7)。

題解：
dp[i]: 無視 [i + 1, K] 的所有球時的解。
令 s[i]: [1, i] 的球的總數
dp[0] = 1
dp[i] = dp[i - 1] * H(s[i - 1] + 1, C[i] - 1)
也就是從前面的排列裡選縫隙插入

## H

題目敘述:
 x - 1, x^2 - 1, ..., x^（p - 2） - 1 都不能被p整除，但是x^(p-1)-1 可以被p整除  (1 ≤ x < p)
 給你p問你符合上目敘述的x有幾個 (2 ≤ p < 2000)

題解:
直接枚舉所有可能x去判斷是否符合條件即可。



給p，知原根存在，算$phi(phi(p)) = phi(p-1)$，即小於等於p-1但與p-1互質正整數的個數。

## I

題目敘述：
給一個N，把2 ~ N+1塗上顏色，但一個數字的顏色不能與他的質因數顏色相同
問最少需要幾種顏色，以及該怎麼塗

題解：
直接把所有的質數塗一種顏色，所有的合數塗另一種顏色即可

## J
題目敘述：
你有一堆寶石排成一列，寶石有顏色。
每次操作可以選擇一個寶石，則和該寶石相鄰的所有同色寶石都會消失，產生的縫隙會被貼合。
一次操作的貢獻是刪除的寶石數量的平方，問最大總貢獻。

題解：
dp[i][j][h]: [i, j] 區間內的寶石，且在 i 的左邊有 h 個準備要接上的顏色為 C[i] 的寶石，這個狀態下的解。
為了方便說明，這裡假設所有相鄰寶石顏色相異(實作上可以考慮 RLE 壓縮, e.g. 122223331 -> 1(1)2(4)3(3)1(1))。
用記憶化搜索計算，轉移有兩種：
1. 把寶石 i 以及 h 用掉，並加上 dp[i + 1][j][0] 的解。
2. 枚舉 m，最大化 dp[i + 1][m - 1][0] + dp[m][j][h + size(i)]